diff --git a/agents/salesAgent.js b/agents/salesAgent.js
index 9e04167..9661b9b 100644
--- a/agents/salesAgent.js
+++ b/agents/salesAgent.js
@@ -47,6 +47,30 @@ const toolResponse = (content, toolCallId) => ({
   tool_call_id: toolCallId
 });
 
+// CRITICAL: Helper function to find current task input from various config paths
+function getCurrentTaskInput(config) {
+  // Check multiple paths where state might be stored
+  const paths = [
+    config?.configurable?.__pregel_scratchpad?.currentTaskInput,
+    config?.configurable?.currentTaskInput,
+    config?.currentTaskInput,
+    config?.state,
+    config
+  ];
+  
+  for (const path of paths) {
+    if (path && typeof path === 'object') {
+      // If we find leadInfo, we likely found the right path
+      if (path.leadInfo || path.contactId || path.messages) {
+        return path;
+      }
+    }
+  }
+  
+  // Return empty object if nothing found
+  return {};
+}
+
 // Define custom state schema with Annotation.Root
 const AgentStateAnnotation = Annotation.Root({
   // Include messages from MessagesAnnotation
@@ -134,9 +158,9 @@ const extractLeadInfo = tool(
     });
     
     try {
-      // Access state from __pregel_scratchpad.currentTaskInput
-      const currentTaskInput = config?.configurable?.__pregel_scratchpad?.currentTaskInput || {};
-      const currentLeadInfo = currentTaskInput.leadInfo || config?.configurable?.leadInfo || {};
+      // FIXED: Use helper to get state from various config paths
+      const currentTaskInput = getCurrentTaskInput(config);
+      const currentLeadInfo = currentTaskInput.leadInfo || {};
       const extractionCount = currentTaskInput.extractionCount || 0;
       const processedMessages = currentTaskInput.processedMessages || [];
       const stateMessages = currentTaskInput.messages || [];
@@ -662,9 +686,9 @@ const getCalendarSlots = tool(
   async ({ startDate, endDate }, config) => {
     const toolCallId = config.toolCall?.id || 'get_calendar_slots';
     
-    // Access state from __pregel_scratchpad.currentTaskInput
-    const currentTaskInput = config?.configurable?.__pregel_scratchpad?.currentTaskInput || {};
-    const currentLeadInfo = currentTaskInput.leadInfo || config?.configurable?.leadInfo || {};
+    // FIXED: Use helper to get state
+    const currentTaskInput = getCurrentTaskInput(config);
+    const currentLeadInfo = currentTaskInput.leadInfo || {};
     
     // Initialize services if not provided - check multiple config paths
     let ghlService = config?.configurable?.ghlService || 
@@ -928,8 +952,8 @@ const updateGHLContact = tool(
   async ({ tags, notes }, config) => {
     const toolCallId = config.toolCall?.id || 'update_ghl_contact';
     
-    // Access state from __pregel_scratchpad.currentTaskInput
-    const currentTaskInput = config?.configurable?.__pregel_scratchpad?.currentTaskInput || {};
+    // FIXED: Use helper to get state
+    const currentTaskInput = getCurrentTaskInput(config);
     const contactId = currentTaskInput.contactId || config?.configurable?.contactId;
     const leadInfo = currentTaskInput.leadInfo || {};
     
@@ -1129,8 +1153,8 @@ const sendGHLMessage = tool(
       messagePreview: message.substring(0, 50)
     });
     
-    // Access state from __pregel_scratchpad.currentTaskInput
-    const currentTaskInput = config?.configurable?.__pregel_scratchpad?.currentTaskInput || {};
+    // FIXED: Use helper to get state
+    const currentTaskInput = getCurrentTaskInput(config);
     const contactId = currentTaskInput.contactId || config?.configurable?.contactId;
     
     if (!contactId) {
@@ -1537,12 +1561,23 @@ export async function salesAgentInvoke(input, agentConfig) {
     ...agentConfig,
     configurable: {
       ...agentConfig?.configurable,
-      thread_id: contactId || 'default',  // For conversation persistence
+      thread_id: input.threadId || contactId || 'default',  // FIXED: Use threadId from input
       conversationStartTime: startTime,
       agentConfig: AGENT_CONFIG,
       // Pass GHL service and calendar ID for tools
       ghlService: agentConfig?.configurable?.ghlService,
-      calendarId: agentConfig?.configurable?.calendarId
+      calendarId: agentConfig?.configurable?.calendarId,
+      // CRITICAL: Pass state through __pregel_scratchpad for tools to access
+      __pregel_scratchpad: {
+        currentTaskInput: {
+          leadInfo: input.leadInfo || {},
+          contactId: contactId,
+          threadId: input.threadId || contactId || 'default',
+          conversationId: input.conversationId,
+          extractionCount: 0,
+          processedMessages: []
+        }
+      }
     }
   };
   
diff --git a/agents/webhookHandler.js b/agents/webhookHandler.js
index d5f8f0e..14397cd 100644
--- a/agents/webhookHandler.js
+++ b/agents/webhookHandler.js
@@ -83,29 +83,28 @@ interceptLangSmithRequests();
 let ghlService;
 let conversationManager;
 
-// Message deduplication cache with automatic cleanup
-class MessageCache {
+// FIXED: Thread-aware message cache for proper deduplication
+class ThreadAwareMessageCache {
   constructor(ttl = 10 * 60 * 1000) {
     this.cache = new Map();
-    this.ttl = config.features.enableDeduplication ? ttl : 0;
-    
-    // Start cleanup interval if deduplication is enabled
-    if (this.ttl > 0) {
-      this.cleanupInterval = setInterval(() => this.cleanup(), 60000); // Clean every minute
-    }
+    this.ttl = ttl;
+    this.cleanupInterval = setInterval(() => this.cleanup(), 60000);
+  }
+  
+  getKey(threadId, messageHash) {
+    return `${threadId}:${messageHash}`;
   }
   
-  add(key, value = Date.now()) {
-    if (this.ttl === 0) return;
+  add(threadId, messageHash, value = Date.now()) {
+    const key = this.getKey(threadId, messageHash);
     this.cache.set(key, { timestamp: value, data: true });
   }
   
-  has(key) {
-    if (this.ttl === 0) return false;
+  has(threadId, messageHash) {
+    const key = this.getKey(threadId, messageHash);
     const entry = this.cache.get(key);
     if (!entry) return false;
     
-    // Check if expired
     if (Date.now() - entry.timestamp > this.ttl) {
       this.cache.delete(key);
       return false;
@@ -120,25 +119,17 @@ class MessageCache {
         this.cache.delete(key);
       }
     }
-    logger.debug('Message cache cleanup', { 
-      size: this.cache.size,
-      ttl: this.ttl 
-    });
-  }
-  
-  clear() {
-    this.cache.clear();
   }
   
   stop() {
     if (this.cleanupInterval) {
       clearInterval(this.cleanupInterval);
     }
-    this.clear();
+    this.cache.clear();
   }
 }
 
-const processedMessages = new MessageCache();
+const processedMessages = new ThreadAwareMessageCache();
 
 // Register cleanup on shutdown
 if (typeof onShutdown === 'function') {
@@ -241,8 +232,7 @@ async function initialize(retries = 3) {
 }
 
 /**
- * Webhook handler node for processing incoming messages
- * Follows LangGraph best practices with state management
+ * UPDATED webhook handler node with proper state management
  * @param {Object} state - Current graph state
  * @param {Array} state.messages - Message history
  * @param {string} state.contactId - GHL contact identifier
@@ -252,14 +242,22 @@ async function initialize(retries = 3) {
  */
 async function webhookHandlerNode(state, config) {
   const startTime = Date.now();
-  // Generate a proper UUID if no runId provided
   const traceId = config?.runId || crypto.randomUUID();
   
+  // CRITICAL: Get thread ID for conversation continuity
+  const threadId = config?.configurable?.thread_id || 
+                   state.threadId || 
+                   config?.configurable?.__pregel_thread_id ||
+                   `thread_${state.contactId}`;
+  
   logger.info('üîç WEBHOOK HANDLER START', {
     traceId,
+    threadId,
     stateMessagesCount: state.messages?.length || 0,
     hasContactId: !!state.contactId,
     hasPhone: !!state.phone,
+    hasLeadInfo: !!state.leadInfo,
+    existingLeadFields: state.leadInfo ? Object.keys(state.leadInfo).filter(k => state.leadInfo[k]) : [],
     timestamp: new Date().toISOString()
   });
   
@@ -417,41 +415,26 @@ async function webhookHandlerNode(state, config) {
   }
   */
   
-  // Create message hash for deduplication
+  // Check message deduplication with thread awareness
   const messageHash = crypto.createHash('md5')
     .update(`${contactId}-${message}-${phone}`)
     .digest('hex');
   
-  // Check if we've already processed this exact message recently
-  const enableDeduplication = config?.configurable?.features?.enableDeduplication ?? true;
-  if (enableDeduplication && processedMessages.has(messageHash)) {
-    const processedTime = Date.now();
-    const timeSince = Date.now() - processedTime;
+  if (processedMessages.has(threadId, messageHash)) {
     logger.info('üîÅ DUPLICATE MESSAGE DETECTED', {
       traceId,
+      threadId,
       contactId,
-      messagePreview: message.substring(0, 30) + '...',
-      hash: messageHash,
-      timeSinceProcessed: timeSince,
-      processingSkipped: true
+      messagePreview: message.substring(0, 30) + '...'
     });
     
-    // Return empty state to indicate no processing needed
     return {
       messages: state.messages,
       duplicate: true
     };
   }
   
-  // Mark message as processed
-  if (enableDeduplication) {
-    processedMessages.add(messageHash, Date.now());
-    logger.debug('üìå Message marked as processed', {
-      traceId,
-      hash: messageHash,
-      cacheSize: processedMessages.size
-    });
-  }
+  processedMessages.add(threadId, messageHash);
   
   logger.info('‚úÖ WEBHOOK VALIDATION PASSED', { 
     traceId,
@@ -462,15 +445,15 @@ async function webhookHandlerNode(state, config) {
     hash: messageHash
   });
   
-  // Get conversationId from state or config
+  // Get conversation state WITH thread awareness
   const conversationId = state.conversationId || config?.configurable?.conversationId || null;
   
   logger.info('üîÑ FETCHING CONVERSATION STATE', {
     traceId,
+    threadId,
     contactId,
     conversationId,
-    phone,
-    conversationIdProvided: !!conversationId
+    phone
   });
   
   const conversationStatePromise = conversationManager.getConversationState(
@@ -492,11 +475,16 @@ async function webhookHandlerNode(state, config) {
     
     logger.info('‚úÖ CONVERSATION STATE FETCHED', {
       traceId,
+      threadId,
       conversationId: conversationState.conversationId,
       messageCount: conversationState.messages?.length || 0,
-      hasLeadInfo: !!(conversationState.leadName || conversationState.leadEmail),
-      leadName: conversationState.leadName || 'not-set',
-      leadBudget: conversationState.leadBudget || 'not-set'
+      existingLeadInfo: {
+        name: conversationState.leadName,
+        problem: conversationState.leadProblem,
+        goal: conversationState.leadGoal,
+        budget: conversationState.leadBudget,
+        email: conversationState.leadEmail
+      }
     });
   } catch (error) {
     logger.error('‚ùå CONVERSATION FETCH FAILED', { 
@@ -537,16 +525,30 @@ async function webhookHandlerNode(state, config) {
     leadInfoFromHistory: !!conversationState.leadName || !!conversationState.leadBudget
   });
   
-  // Extract current lead info for context
+  // CRITICAL: Merge existing lead info with any passed state
   const currentLeadInfo = {
-    name: conversationState.leadName,
-    problem: conversationState.leadProblem,
-    goal: conversationState.leadGoal,
-    budget: conversationState.leadBudget,
-    email: conversationState.leadEmail,
-    phone: formatPhoneNumber(phone)
+    name: state.leadInfo?.name || conversationState.leadName,
+    problem: state.leadInfo?.problem || conversationState.leadProblem,
+    goal: state.leadInfo?.goal || conversationState.leadGoal,
+    budget: state.leadInfo?.budget || conversationState.leadBudget,
+    email: state.leadInfo?.email || conversationState.leadEmail,
+    phone: formatPhoneNumber(phone),
+    businessType: state.leadInfo?.businessType || conversationState.leadBusinessType
   };
   
+  logger.info('üìã MERGED LEAD INFO', {
+    traceId,
+    threadId,
+    currentLeadInfo,
+    hasAllRequiredInfo: !!(
+      currentLeadInfo.name && 
+      currentLeadInfo.problem && 
+      currentLeadInfo.goal && 
+      currentLeadInfo.budget && 
+      currentLeadInfo.email
+    )
+  });
+  
   logger.debug('üìã Current lead info', {
     traceId,
     ...currentLeadInfo,
@@ -620,22 +622,22 @@ async function webhookHandlerNode(state, config) {
   if (cachedResponse) {
     logger.info('üí® USING CACHED RESPONSE', {
       traceId,
+      threadId,
       message: message.substring(0, 50),
-      cachedResponseLength: cachedResponse.length,
-      savedTokens: 3822  // Average tokens saved
+      savedTokens: 3822
     });
     
-    // Send cached response directly
     try {
       await ghlService.sendSMS(contactId, cachedResponse);
       
-      // Return early with minimal state update
       return {
         ...state,
         messages: [
           ...state.messages,
           new AIMessage(cachedResponse)
         ],
+        leadInfo: currentLeadInfo,
+        threadId,
         cached: true,
         processingTime: Date.now() - startTime
       };
@@ -645,101 +647,83 @@ async function webhookHandlerNode(state, config) {
         contactId,
         traceId
       });
-      // Fall through to normal processing if cache send fails
     }
   }
   
-  // Invoke the sales agent with proper configuration
+  // Invoke sales agent with proper state
   logger.info('ü§ñ INVOKING SALES AGENT', {
     traceId,
+    threadId,
     contactId,
     conversationId: conversationState.conversationId,
-    messageCount: agentMessages.length
+    messageCount: agentMessages.length,
+    leadInfoFields: Object.keys(currentLeadInfo).filter(k => currentLeadInfo[k])
   });
   
   const agentStartTime = Date.now();
   const result = await salesAgentInvoke({
-    messages: agentMessages,  // Only current message
-    // Pass current lead info as context
+    messages: agentMessages,
     leadInfo: currentLeadInfo,
     contactId,
     conversationId: conversationState.conversationId,
-    // Pass conversation history separately for context
+    threadId,
     conversationHistory: conversationHistory
   }, {
-    // Configuration for tools - matching config parameter pattern
     configurable: {
       ghlService,
       calendarId: process.env.GHL_CALENDAR_ID,
-      contactId
+      contactId,
+      thread_id: threadId,
+      __pregel_scratchpad: {
+        currentTaskInput: {
+          leadInfo: currentLeadInfo,
+          contactId,
+          threadId,
+          conversationId: conversationState.conversationId
+        }
+      }
     },
-    runId: traceId  // Pass trace ID to agent
+    runId: traceId
   });
   
   logger.info('‚úÖ AGENT RESPONSE RECEIVED', {
     traceId,
+    threadId,
     agentProcessingTime: Date.now() - agentStartTime,
     responseMessageCount: result.messages?.length || 0,
     appointmentBooked: result.appointmentBooked || false,
-    leadInfoUpdated: Object.keys(result.leadInfo || {}).length > Object.keys(currentLeadInfo).filter(k => currentLeadInfo[k]).length
+    leadInfoUpdated: result.leadInfo ? Object.keys(result.leadInfo).filter(k => result.leadInfo[k]) : []
   });
   
-  // Clear conversation cache (non-blocking)
+  // Clear conversation cache
   setImmediate(() => {
     conversationManager.clearCache(contactId, conversationState.conversationId);
-    logger.debug('üßπ Cache cleared', {
-      traceId,
-      contactId,
-      conversationId: conversationState.conversationId
-    });
   });
   
-  logger.info('‚úÖ WEBHOOK PROCESSED SUCCESSFULLY', {
-    traceId,
-    totalProcessingTime: Date.now() - startTime,
-    contactId,
-    finalMessageCount: result.messages?.length || 0,
-    appointmentBooked: result.appointmentBooked || false
-  });
-  
-  // Record success for circuit breaker
-  circuitBreaker.recordSuccess();
-  
-  // Return updated state with messages following MessagesAnnotation pattern
+  // Return updated state with ALL information preserved
   return {
     messages: result.messages,
     contactId,
     phone,
-    leadInfo: result.leadInfo || currentLeadInfo  // Use updated leadInfo from agent
+    leadInfo: result.leadInfo || currentLeadInfo,
+    threadId,
+    conversationId: conversationState.conversationId,
+    appointmentBooked: result.appointmentBooked || false,
+    processingTime: Date.now() - startTime
   };
   
   } catch (error) {
     logger.error('‚ùå WEBHOOK HANDLER ERROR', {
       traceId,
+      threadId,
       error: error.message,
       stack: error.stack,
-      contactId: state.contactId,
-      errorType: error.name,
-      errorCode: error.code,
-      phase: 'webhook_processing',
-      inputMessages: state.messages?.length || 0,
-      lastMessage: state.messages?.[state.messages.length - 1]?.content?.substring(0, 100),
-      processingTimeBeforeError: Date.now() - startTime
+      contactId: state.contactId
     });
     
-    // Record failure for circuit breaker
     circuitBreaker.recordFailure();
     
-    // Log to LangSmith trace if available
-    if (config.callbacks) {
-      config.callbacks.handleError?.(error);
-    }
-    
-    
-    // Return user-friendly error message for other errors
-    const errorMessage = error.name === 'CancelledError' || error.message.includes('cancelled')
-      ? 'Hubo una interrupci√≥n temporal. Por favor, env√≠a tu mensaje nuevamente.'
-      : 'Lo siento, hubo un error procesando tu mensaje. Por favor intenta de nuevo.';
+    const errorMessage = 'Lo siento, hubo un error procesando tu mensaje. Por favor intenta de nuevo.';
     
     return {
       messages: [
@@ -750,14 +734,16 @@ async function webhookHandlerNode(state, config) {
         })
       ],
       contactId: state.contactId,
-      phone: state.phone
+      phone: state.phone,
+      leadInfo: state.leadInfo,
+      threadId
     };
   }
 }
 
-// Define extended state annotation for webhook handler
+// UPDATED: Extended state annotation with thread support
 const WebhookAnnotation = Annotation.Root({
-  ...MessagesAnnotation.spec,  // Use the spec to properly inherit message handling
+  ...MessagesAnnotation.spec,
   contactId: Annotation({
     default: () => null
   }),
@@ -767,6 +753,15 @@ const WebhookAnnotation = Annotation.Root({
   leadInfo: Annotation({
     reducer: (x, y) => ({ ...x, ...y }),
     default: () => ({})
+  }),
+  threadId: Annotation({
+    default: () => null
+  }),
+  conversationId: Annotation({
+    default: () => null
+  }),
+  appointmentBooked: Annotation({
+    default: () => false
   })
 });
 
diff --git a/analyze-trace.js b/analyze-trace.js
index 6b1cab6..801b6a5 100644
--- a/analyze-trace.js
+++ b/analyze-trace.js
@@ -1,11 +1,16 @@
 import { Client } from 'langsmith';
+import dotenv from 'dotenv';
+
+// Load environment variables
+dotenv.config();
 
 // Initialize LangSmith client
 const client = new Client({
   apiKey: process.env.LANGSMITH_API_KEY
 });
 
-const traceId = process.env.LANGCHAIN_TRACE_ID || '1f06bb79-e546-6703-946f-9b59b39e4a2f';
+// Get trace ID from command line argument or environment variable
+const traceId = process.argv[2] || process.env.LANGCHAIN_TRACE_ID || '1f06bb79-e546-6703-946f-9b59b39e4a2f';
 
 async function analyzeTrace() {
   console.log(`üîç Analyzing LangSmith Trace: ${traceId}\n`);
diff --git a/api/langgraph-api.js b/api/langgraph-api.js
index 17e6f37..43cf8d1 100644
--- a/api/langgraph-api.js
+++ b/api/langgraph-api.js
@@ -11,7 +11,7 @@ const logger = new Logger('langgraph-api');
 
 /**
  * Main webhook endpoint for LangGraph Platform
- * Receives webhooks from GHL and processes them through the sales agent
+ * FIXED: Maintains conversation continuity using conversationId as thread_id
  */
 export default async function handler(req, res) {
   logger.info('Webhook received', {
@@ -46,43 +46,63 @@ export default async function handler(req, res) {
       });
     }
 
+    // CRITICAL FIX: Use conversationId as thread_id for continuity
+    // If no conversationId, use contactId to ensure same contact keeps same thread
+    const threadId = conversationId || `thread_${contactId}`;
+    
+    logger.info('Using thread ID for continuity', {
+      threadId,
+      conversationId,
+      contactId,
+      isNewThread: !conversationId
+    });
+
     // CRITICAL FIX: Pass the actual message content, not JSON
-    // The webhook handler will handle the message directly
     const state = {
-      messages: [new HumanMessage(message)],  // Just the message content
+      messages: [new HumanMessage(message)],
       contactId,
-      phone: phone || '',  // Phone might be optional
-      conversationId: conversationId || contactId  // Use contactId as fallback
+      phone: phone || '',
+      conversationId: conversationId || contactId,
+      // Pass thread_id in state for tools to access
+      threadId: threadId
     };
 
     // Process through webhook handler
     logger.info('Processing webhook', { 
       contactId, 
       conversationId,
+      threadId,
       phone, 
       messageLength: message.length 
     });
     
+    // FIXED: Use consistent thread_id for conversation continuity
     const result = await webhookHandler.invoke(state, {
       configurable: {
-        thread_id: contactId,
+        thread_id: threadId,  // CRITICAL: Use consistent thread ID
         contactId,
-        conversationId,
+        conversationId: conversationId || contactId,
         phone,
-        locationId
+        locationId,
+        // Pass thread info for tools
+        __pregel_thread_id: threadId
       }
     });
 
     logger.info('Webhook processed successfully', { 
       contactId, 
-      messagesProcessed: result.messages?.length 
+      threadId,
+      messagesProcessed: result.messages?.length,
+      leadInfoCollected: Object.keys(result.leadInfo || {}).filter(k => result.leadInfo[k]).length
     });
 
-    // Return success response
+    // Return success response with thread info
     return res.status(200).json({ 
       success: true,
       message: 'Webhook processed successfully',
-      contactId
+      contactId,
+      threadId,  // Return thread ID for debugging
+      leadInfo: result.leadInfo  // Return collected info
     });
 
   } catch (error) {
